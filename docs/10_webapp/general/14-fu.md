# FU: 14. 악성 파일 업로드

**분류**: Web Application(웹)

**중요도**: 상

---

## 개요

### 점검 내용

웹 애플리케이션 내 업로드 기능 이용 시 악성 파일의 업로드 및 실행 가능 여부 점검

### 점검 목적

업로드되는 파일의 확장자에 대한 적절성을 검증하는 로직을 구현하여 악성 파일(Server Side Script, exe, dll, bat 등)의 업로드를 방지하고, 서버에 저장된 파일 경로를 유추하여 해당 파일의 실행을 제한하기 위함

### 보안 위협

해당 취약점이 존재할 경우, 공격자는 악성 파일을 서버에 업로드 및 실행하여 시스템 관리자 권한을 획득하거나 인접 서버에 대한 침입을 시도할 수 있음

### 참고

!!! info "Server Side Script"
    웹에서 사용되는 스크립트 언어 중 서버 측에서 실행되는 스크립트

!!! info "악성 콘텐츠"
    Flash 파일이나 dll, bat, exe 실행 파일 등 악성코드가 포함될 수 있는 콘텐츠

!!! info "업로드 기능 제한"
    기반시설 특성상 원칙적으로 업로드 기능을 제한해야 하나, 부득이하게 사용해야 하는 경우 특정 사용자만 허용된 확장자의 콘텐츠 파일을 업로드할 수 있도록 구현

!!! info "참고"
    소스코드 및 취약점 점검 필요

## 점검 대상 및 판단 기준

### 대상

웹 애플리케이션 소스코드, 웹 애플리케이션 서버, 웹 방화벽

### 판단 기준

**✅ 양호**: 업로드되는 파일에 대한 확장자 검증이 이루어지는 경우

**❌ 취약**: 업로드되는 파일에 대한 확장자 검증이 이루어지지 않고 업로드 경로 접근 시 정상적으로 실행이 가능한 경우

## 조치 방법

업로드되는 파일에 대한 확장자 검증 및 실행 권한 제거

### 조치 시 영향

일반적인 경우 영향 없음

## 점검 및 조치 사례

### 악성 콘텐츠 업로드

**점검 방법**

**Step 1)** 파일 업로드 기능 이용 시 파일 확장자(.exe, .bat, .sh, .dll 등) 검증 여부 확인

**[ 악성 파일 업로드 시도 ]**

**Step 2)** 임의 악성 파일에 대하여 정상적으로 업로드 가능 여부 확인

**[ 악성 파일 업로드 유무 확인 ]**

**Step 3)** 파일 다운로드 및 특정 서비스 간 실행 기능 제공 시 클라이언트/서버에 대하여 악성 코드 감염 가능성 여부 확인

**[ 악성 파일에 대한 익스플로잇 및 실행 가능성 여부 확인 ]**

### Server Side Script 업로드

**점검 방법**

**Step 1)** Server Side Script 파일 업로드 및 파일 경로 확인

**[ 업로드 된 악성 Server Side Script에 대한 경로 확인 ]**

**Step 2)** 업로드된 Server Side Script 파일 경로 접근 시 파일 실행 여부 확인

**[ 악성 Server Side Script 실행 유무 확인 ]**

**조치 방법**

1. 업로드 파일명에 인코딩/디코딩, 널바이트, 태그 등을 제거할 수 있도록 정규화 및 필터링
2. 업로드 파일의 확장자 및 MIME 타입에 대해 화이트리스트 방식으로 검증 로직을 구현하여 서버 사이드로 하여금 허용된 파일 유형만 업로드를 허용하며 대용량 파일 업로드 시 용량 제한 구현
3. 업로드된 파일의 이름을 암호화 후 저장하여 파일 이름을 유추할 수 없도록 처리
4. 업로드된 파일의 실행 권한을 제한하여 해당 파일이 서버 사이드에서 실행되지 않도록 설정
5. 업로드 경로에 대하여 웹 디렉터리와 격리 조치
6. 주기적으로 업로드된 파일을 대상으로 바이러스 검사 실시

#### Java 파일 업로드 보안 코드

화이트리스트 방식의 확장자 검증 및 MIME 타입 검증 로직을 구현하여 허용된 유형의 파일만 업로드 허용

```java
private static final String[] ALLOWED_EXTENSIONS = {"jpg", "png", "pdf", "txt"};
private static final Set<String> ALLOWED_MIME = Set.of("image/jpeg", "image/png", "application/pdf", "text/plain");

// 파일명 정규화
private static String normalizeFilename(String filename) {
    if (filename == null) return null;
    String name = java.net.URLDecoder.decode(filename, StandardCharsets.UTF_8);
    name = Normalizer.normalize(name, Normalizer.Form.NFC);
    name = name.replace("\0", "");
    name = name.replaceAll("[<>:\"/\\\\|?*]", "");
    name = name.replaceAll("^[.\\s]+|[.\\s]+$", "");
    return name;
}

// 확장자 추출 + 이중 확장자 차단
private static String getExtension(String filename) {
    String safe = normalizeFilename(filename);
    int dotCount = safe.length() - safe.replace(".", "").length();
    if (dotCount != 1) return ""; // 이중 확장자 차단
    int idx = safe.lastIndexOf('.');
    if (idx == -1) return "";
    return safe.substring(idx+1).toLowerCase();
}

public static String saveFile(MultipartFile file, String uploadDir) throws IOException {
    String original = file.getOriginalFilename();
    String ext = getExtension(original);
    if (!ALLOWED_EXTENSIONS.contains(ext)) {
        throw new IOException("허용되지 않은 확장자");
    }
    
    // MIME 시그니처 검증
    Tika tika = new Tika();
    String mime = tika.detect(file.getInputStream());
    if (!ALLOWED_MIME.contains(mime)) {
        throw new IOException("허용되지 않은 파일 유형");
    }
    
    // 파일명 난수화
    String newName = UUID.randomUUID().toString().replace("-", "") + "." + ext;
    java.nio.file.Path savePath = java.nio.file.Paths.get(uploadDir, newName);
    file.transferTo(savePath.toFile());
    return newName;
}
```
